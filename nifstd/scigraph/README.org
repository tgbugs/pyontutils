# -*- org-adapt-indentation: nil; org-edit-src-content-indentation: 0; -*-
#+TITLE: Using SciGraph
#+OPTIONS: num:nil
#+STARTUP: showall

# [[file:./README.html]]

This readme consolidates a number of different processes for deploying
ontologies to SciGraph into a single workflow that avoids most of the
hidden pitfalls we have encountered over the past 4 years.

*NOTE*: if you are using a non-standard location for =~/git= then the best
way to fix this file at the moment is to do a global find and replace.

* Using this file
Before you can use this file you will need to complete the [[#setup][Setup section]]. \\

You can either [[https://orgmode.org/manual/Extracting-Source-Code.html][tangle]]
this file in emacs using =C-c C-v t= or you can tangle
the whole file from the command line using with the following.

#+name: tangle-this-file
#+header: :results none
#+begin_src bash :var THIS_FILE=(let ((home (expand-file-name "~")) (bfn (buffer-file-name))) (when (string-prefix-p home bfn) (concat "~" (substring bfn (length home) nil)))) :noweb yes
: ${THIS_FILE:="README.org"}    # set to the local path to this file
emacs --batch \
      --load org \
      --load ob-shell \
      --eval "(unless ((lambda (a b) (or (string> a b) (string= a b))) (org-version) \"9.3\") (message (format \"your org is too old! %s < 9.3 try loading ~/git/orgstrap/init.el\" (org-version))) (kill-emacs 1))" \
      --eval "(org-babel-tangle-file \"${THIS_FILE}\")"
#+end_src

The core functionality is tangled to [[file:./bin/scigraph-functions.sh]]. \\
It can be sourced in a shell or from a script by running \\
=source ~/git/pyontutils/nifstd/scigraph/bin/scigraph-functions.sh= \\
to make the functions defined in this file available for use.

#+name: fail-if-not-sourced
#+caption: Fail if [[file:./bin/scigraph-functions.sh]] is not sourced.
#+begin_src bash :exports none :tangle ./bin/scigraph-functions.sh
if [ "${BASH_SOURCE[0]}" -ef "$0" ]; then
    echo "${0} is not an executable shell script."
    echo "Instead run \`source ${0}\`"
    exit 1
fi
#+end_src
** Developing this file                                            :noexport:
If you are using emacs, then =flycheck-mode= will run =shellcheck= for you!
You don't even have to run it independently.

You should also run =shellcheck= on the tangled file if you make any changes.
You don't usually have to worry about green issues, and there are a number of
false positives because we are dealing with some crazy local vs remote expansion.
#+name: run-shellcheck
#+begin_src bash :noweb yes :eval never
shellcheck "<<path-scigraph-functions()>>"
#+end_src
* Setup
:properties:
:CUSTOM_ID: setup
:visibility: folded
:end:
** Build host
*** Gentoo
:PROPERTIES:
:CUSTOM_ID: Setup:Build host:Gentoo
:END:
#+begin_src bash
layman -a tgbugs-overlay

emerge \
pyontutils \
rpmdevtools \
scigraph-bin \
yq
#+end_src
*** Ubuntu
:PROPERTIES:
:CUSTOM_ID: Setup:Build host:Ubuntu
:END:
#+begin_src bash
apt install \
rpm \
python3-dev \
python3-pip

pip install --user \
pyontutils \
yq
#+end_src
** Services host
*** Gentoo
:PROPERTIES:
:CUSTOM_ID: Setup:Services host:Gentoo
:END:
#+begin_src bash
layman -a tgbugs-overlay

emerge \
scigraph-bin \
yq
#+end_src
*** AWS Linux 2
:PROPERTIES:
:CREATED:  [2020-01-06 Mon 14:27]
:CUSTOM_ID: Setup:Services host:AWS Linux 2
:END:
Installing the scigraph RPM also handles the creation and configuration
of all relevant variables for operation on RHEL-like systems.
See the [[https://github.com/tgbugs/pyontutils/blob/master/nifstd/scigraph/scigraph.spec][spec file]]
for details.

#+name: dir-tramp-sudo
#+header: :noweb yes :results none
#+begin_src emacs-lisp :exports none
(defun :dir-tramp-sudo (ssh-config-hostname)
  (format "/ssh:%s|sudo:%s:" ssh-config-hostname ssh-config-hostname))
#+end_src

#+name: aws-block
#+begin_src bash :dir /ssh:hostname|sudo:hostname:
yum install -y \
python3 \
python3-pip

pip3 install \
yq  # yq is usually only needed on config build systems
    # however if something goes wrong and an in place change
    # needs to be made then editing the raw and regenerating
    # is the preferred course of action
#+end_src

# #+CALL: aws-block() :dir /ssh:aws-scigraph|sudo:aws-scigraph: :eval never
# #+CALL: aws-block() :dir (:dir-tramp-sudo "aws-scigraph") :eval never
* User setup
:properties:
:visibility: folded
:end:
This setup should be completed on the build host or on the ops host
that talks to both the build host and the services host. Currently the
build host and ops host are conflated.
** git repos
There are currently still a couple of repos that are needed for these workflows.
Most are needed configuration files, but pyontutils is needed for this README as well.
#+begin_src bash :eval never
pushd ~/git
git clone https://github.com/tgbugs/orgstrap.git
git clone https://github.com/tgbugs/pyontutils.git
git clone https://github.com/tgbugs/tgbugs-overlay.git
git clone https://github.com/SciCrunch/sparc-curation.git
popd
~/git/orgstrap/orgstrap --user  # needed to obtain newer version of org-mode
#+end_src
** ssh config
When viewing this file in emacs tangle this block after setting
the requisite values below in the variables section (not exported).
Alternately, copy the block as is an make the changes manually.
Then open [[file:${HOME}/.ssh/config.scigraph.example][~/.ssh/config.scigraph.example]]
and copy the sections into [[file:${HOME}/.ssh/config][your ssh config file]].

If you are deploying to an aws server (e.g. aws-scigraph or aws-scigraph-data),
the =IdentityFile= entry must point to a key that has admin access via the aws console.
#+begin_src ssh-config :noweb yes :tangle ~/.ssh/config.scigraph.example
# enable connection multiplexing for all hosts
Host *
ServerAliveInterval 60
ControlMaster auto
ControlPath ~/.ssh_tmp/master-%r@%h:%p

# jump host should be whitelisted in the target's firewall
Host <<jump-host()>>
HostName <<ip-jump-host()>>
User <<user-jump-host()>>
IdentityFile <<path-jump-identity-file()>>
PreferredAuthentications publickey

Host aws-scigraph
HostName <<ip-aws-scigraph()>>
User ec2-user
IdentityFile <<path-target-identity-file()>>
PreferredAuthentications publickey
ProxyCommand ssh <<jump-host()>> -W %h:%p

Host aws-scigraph-scigraph
HostName <<ip-aws-scigraph()>>
User scigraph
IdentityFile ~/.ssh/id_ed25519.aws.scigraph
PreferredAuthentications publickey
ProxyCommand ssh <<jump-host()>> -W %h:%p

Host aws-scigraph-data
HostName <<ip-aws-scigraph-data()>>
User ec2-user
IdentityFile <<path-target-identity-file()>>
PreferredAuthentications publickey
ProxyCommand ssh <<jump-host()>> -W %h:%p

Host aws-scigraph-data-scigraph
HostName <<ip-aws-scigraph-data()>>
User scigraph
IdentityFile ~/.ssh/id_ed25519.aws.scigraph
PreferredAuthentications publickey
ProxyCommand ssh <<jump-host()>> -W %h:%p
#+end_src

Make [[file:${HOME}/.ssh_tmp]] folder to hold multiplexed sockets.
#+begin_src bash
mkdir ~/.ssh_tmp
chmod 0700 ~/.ssh_tmp
#+end_src

Once you have everything above configured you can run the following
to create and deploy ssh key for the scigraph deploy user.
#+begin_src bash :eval never :noweb yes
<<&source-scigraph-functions>>
ssh-keygen-simple \
--server aws-scigraph \
--svc-user scigraph \
--keyname aws.scigraph && \
ssh-copy-id-simple

ssh-copy-id-simple \
--server aws-scigraph-data \
--svc-user scigraph \
--keyname aws.scigraph
#+end_src
For the implementation of the =*-simple= commands see [[#ssh-setup][ssh setup]].
*** variables                                                      :noexport:
:properties:
:custom_id: ssh-variables
:visibility: folded
:end:

# NOTE :noexport: + a reference == cannot find reference (duh)

Set =ip-aws-scigraph= here
#+name: ip-aws-scigraph
: 127.0.0.1

Set =ip-aws-scigraph-data= here
#+name: ip-aws-scigraph-data
: 127.0.0.1

Set =path-target-identity-file= here
#+name: path-target-identity-file
: /dev/null

# NOTE: it is good practice to require any computer wanting to connect
# to have two keys, one for the bastion and one for the target host
# that way if the bastion is compromised the keys to get to the protected
# hosts cannot be obtained from that machine alone
# if a user's machine is compromised then access to the bastion can be
# shut down for just that user and if the jump key is shared, then
# it can be rotated under less time pressure

Set =path-jump-identity-file= here
#+name: path-jump-identity-file
: /dev/null

Set =jump-host= aka bastion server name here
#+name: jump-host
: localhost

Set =ip-jump-host= here
#+name: ip-jump-host
: 127.0.0.1

Set =user-jump-host= here
#+name: user-jump-host
: nobody
* Simple CLI =scigraph-load-graphs=
Cut out the =graphload.yaml= middle man.

Note this currently can't use shell redirection to do things like
=load-graphs <(git show branch:path/to/file.ttl)= though it would
be quite useful to be able to do so.

#+name: &help-load-graphs
#+begin_src bash :noweb yes
Load one or more RDF/OWL graphs into a SciGraph database
Usage:
    scigraph-load-graphs [options] <path-or-iri>...

Examples:
    scigraph-load-graphs --path-output loaded-graph.zip path/to/my/ontology.ttl
    scigraph-load-graphs ttl/nif.ttl ~/git/NIF-Ontology/extra.ttl http://www.w3.org/2002/07/owl#

Options:
    -h --help                 print this message
    --path-output=PATH        full path to the output zip file [default: ./]
    --folder-name-graph=NAME  name of the folder holding the neo4j database [default: test]
    --path-graphload=PATH     full path to the graphload template [default: <<path-graphload-template()>>]
#+end_src

#+name: scigraph-load-graphs
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/scigraph-load-graphs
<<&source-scigraph-functions>>
load-graphs $@
#+end_src

#+name: &vars-load-graphs
#+begin_src bash :eval never :exports none :noweb yes
local POSITIONAL=()
while [[ $# -gt 0 ]]
do
key="$1"
case $key in
    --path-output)       local PATH_OUTPUT="${2}"; shift; shift ;;
    --folder-name-graph) local FOLDER_NAME_GRAPH="${2}"; shift; shift ;;
    --path-graphload)    local PATH_GRAPHLOAD="${2}"; shift; shift ;;
    -h|--help)           echo "${HELP}"; return ;;
    *)                   POSITIONAL+=("$1"); shift ;;
esac
done

if [ -z $POSITIONAL ]; then
    echo "${HELP}"
    return 1
fi

local PATH_OUTPUT=${PATH_OUTPUT:-"./"}
local PATH_BUILD=$(mktemp --directory load-graph-test-XXXX)
local PATH_ONTOLOGIES="${PATH_BUILD}/ontologies.yaml"
local FOLDER_NAME_GRAPH=${FOLDER_NAME_GRAPH:-"test"}
#+end_src

# FIXME scigraph bugs mean that it might make sense to construct a temporary top level ontology file instead
# have to use :comments link here so that tangling the help doesn't break everything
#+name: load-graphs
#+header: :comments link
#+begin_src bash :noweb no-export :tangle ./bin/scigraph-functions.sh
function load-graphs () {
    local HELP="\
<<&help-load-graphs>>"
    <<&vars-load-graphs>>
    echo ontologies: > "${PATH_ONTOLOGIES}"
    for PATH_INPUT in "${POSITIONAL[@]}"; do
        echo "  - url: ${PATH_INPUT}"                                       >> "${PATH_ONTOLOGIES}"
        echo "    reasonerConfiguration:"                                   >> "${PATH_ONTOLOGIES}"
        echo "      factory: org.semanticweb.elk.owlapi.ElkReasonerFactory" >> "${PATH_ONTOLOGIES}"
        echo "      addDirectInferredEdges: true"                           >> "${PATH_ONTOLOGIES}"
        echo "      removeUnsatisfiableClasses: true"                       >> "${PATH_ONTOLOGIES}"
    done
    load-graph
    CODE=$?
    if [ $CODE -ne 0 ]; then
        echo "Loading failed with error ${CODE}"
    else
        mv $(realpath "${PATH_BUILD}/LATEST") "${PATH_OUTPUT}"
    fi
    rm -r "${PATH_BUILD}"
    return $CODE
}
#+end_src
* Deployments
:PROPERTIES:
:header-args: :mkdirp yes
:END:
*NOTE: By default any additional arguments to a =load-deploy= command are passed to the =load= NOT to =deploy=.*
** nifstd
*** code
*** graph
**** load
:properties:
:visibility: folded
:custom_id: nifstd-graph-load
:end:
#+name: run-load-graph-nifstd
#+caption: run-load-graph-nifstd
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-load-graph-nifstd
<<&source-scigraph-functions>>
load-graph-ontload \
--path-build <<path-build-nifstd()>> \
--path-ontologies <<path-ontologies-nifstd()>> \
--git-ref <<git-ref-nifstd()>> \
$@ \
#+end_src
**** deploy
**** deploy from CI
*** services config
**** build
:properties:
:visibility: folded
:end:
#+name: run-build-services-nifstd
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-build-services-nifstd
<<&source-scigraph-functions>>
build-services \
--path-build <<path-build-nifstd()>> \
--path-cypher-resources <<path-cypher-resources-nifstd()>> \
#+end_src
**** deploy
*** variables                                                      :noexport:
:properties:
:visibility: folded
:end:
Set =path-build-nifstd= here
#+name: path-build-nifstd
: /tmp/scigraph-build/nifstd

Set =path-ontologies-nifstd= here
#+name: path-ontologies-nifstd
: ~/git/pyontutils/nifstd/scigraph/ontologies-nifstd.yaml

Set =git-ref-nifstd= here
#+name: git-ref-nifstd
: master

Set =path-cypher-resources-nifstd= here
#+name: path-cypher-resources-nifstd
: ~/git/pyontutils/nifstd/scigraph/cypher-resources.yaml
** sparc
*** ontology
:properties:
:visibility: folded
:custom_id: sparc-ontology
:end:
#+name: &materialize-ifsu
#+begin_src python :exports code :eval never
import pathlib as pl
from pyontutils.core import OntGraph
from pyontutils.namespaces import ilxtr, ILX
g = OntGraph(path=pl.Path('~/git/NIF-Ontology/ttl/sparc-community-terms.ttl').expanduser()).parse()
[g.add((o, ilxtr.includedForSPARCUnder, s)) for s, o in g[:ILX['0738400']:]]
g.write()
#+end_src

Run this block
#+name: sparc-community-terms-update
#+caption: running =interlex-alt= is really all that is required, the url is for simplicity
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :results output :noweb no-export :tangle ./bin/sparc-community-terms-update
pushd ~/git/NIF-Ontology/ttl
git checkout sparc || exit $?  # can fail if your working copy has stuff saved
git pull || exit $?
curl https://alt.olympiangods.org/sparc/ontologies/community-terms.ttl -o sparc-community-terms.ttl || exit $?  # FIXME TEMP url
# FIXME update to production url: http://uri.interlex.org/sparc/ontologies/community-terms.ttl
{ python || exit $?; } <<EOF
<<&materialize-ifsu>>
EOF
git add sparc-community-terms.ttl
git commit -m "update to latest version of sparc-community-terms"
git diff HEAD~1 HEAD | tee sct-diff.patch
popd
#+end_src

Review the output of this block or [[file:${HOME}/git/NIF-Ontology/ttl/sct-diff.patch]]
Make any manual changes, commit, and push.
You will also need to merge sparc into dev for the changes to be included in the SciGraph load. i.e., the following:
#+begin_src bash :eval never
git checkout dev
git merge sparc
#+end_src
*** code
*** graph
**** load
:properties:
:visibility: folded
:custom_id: sparc-graph-load
:end:
#+name: run-load-graph-sparc
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-load-graph-sparc
<<&source-scigraph-functions>>
load-graph-ontload \
--path-build <<path-build-sparc()>> \
--path-ontologies <<path-ontologies-sparc()>> \
--git-ref <<git-ref-sparc()>> \
$@ \
#+end_src
**** deploy
:properties:
:visibility: folded
:end:
#+name: run-deploy-graph-sparc
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-deploy-graph-sparc
<<&source-scigraph-functions>>
deploy-graph \
--server aws-scigraph \
--path-build <<path-build-sparc()>>
#+end_src
**** load-deploy
:properties:
:visibility: folded
:end:
you can run both blocks together with =run-load-deploy-graph-sparc=
#+name: run-load-deploy-graph-sparc
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-load-deploy-graph-sparc :exports none
<<run-load-graph-sparc>>
|| exit $?
<<run-deploy-graph-sparc>>
#+end_src
**** deploy from CI
*** services config
[[tramp:/ssh:aws-scigraph-scigraph:services.yaml]]
**** build
:properties:
:visibility: folded
:end:
#+name: run-build-services-sparc
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-build-services-sparc
<<&source-scigraph-functions>>
build-services \
--path-build <<path-build-sparc()>> \
--svc-host <<host-services-sparc()>> \
--path-cypher-resources <<path-cypher-resources-sparc()>> \
#+end_src
**** deploy
:properties:
:visibility: folded
:end:
#+name: run-deploy-services-sparc
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-deploy-services-sparc
<<&source-scigraph-functions>>
deploy-services \
--config <<path-build-sparc()>>/<<file-stem-services-output()>>.yaml \
--server aws-scigraph
#+end_src
**** build-deploy
:properties:
:visibility: folded
:custom_id: sparc-services-build-deploy
:end:
#+name: run-build-deploy-services-sparc
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-build-deploy-services-sparc
<<run-build-services-sparc>>
|| exit $?
<<run-deploy-services-sparc>>
#+end_src
*** variables                                                      :noexport:
:properties:
:visibility: folded
:end:
**** load graph
Set =path-build-sparc= here
#+name: path-build-sparc
: /tmp/scigraph-build/sparc

Set =path-ontologies-sparc= here
#+name: path-ontologies-sparc
: ~/git/sparc-curation/resources/scigraph/ontologies-sparc.yaml

Set =git-ref-sparc= here
#+name: git-ref-sparc
: dev
**** build services config
Set =path-cypher-resources-sparc= here
#+name: path-cypher-resources-sparc
: ~/git/sparc-curation/resources/scigraph/cypher-resources.yaml

Set =host-services-sparc= here
#+name: host-services-sparc
: scigraph.scicrunch.io
** sparc-data
*** ontology
:properties:
:visibility: folded
:end:
See [[https://github.com/SciCrunch/sparc-curation/blob/master/docs/apinatomy.org]] for
instructions about converting exporting and deploying ApiNATOMY graphs for loading
into SciGraph.
*** code
*** graph
**** load
:properties:
:visibility: folded
:end:
#+name: run-load-graph-sparc-data
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-load-graph-sparc-data
<<&source-scigraph-functions>>
load-graph \
--path-build <<path-build-sparc-data()>> \
--folder-name-graph <<folder-name-graph-sparc-data()>> \
--path-ontologies <<path-ontologies-sparc-data()>> \
$@ \
#+end_src
**** deploy
:properties:
:visibility: folded
:end:
#+name: run-deploy-graph-sparc-data
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-deploy-graph-sparc-data
<<&source-scigraph-functions>>
deploy-graph \
--server aws-scigraph-data \
--path-build <<path-build-sparc-data()>>
#+end_src
**** load-deploy
:properties:
:visibility: folded
:end:
#+name: run-load-deploy-graph-sparc-data
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-load-deploy-graph-sparc-data
<<run-load-graph-sparc-data>>
|| exit $?
<<run-deploy-graph-sparc-data>>
#+end_src
*** services config
[[tramp:/ssh:aws-scigraph-data-scigraph:services.yaml]]
**** build
:properties:
:visibility: folded
:end:
#+name: run-build-services-sparc-data
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-build-services-sparc-data
<<&source-scigraph-functions>>
build-services \
--path-build <<path-build-sparc-data()>> \
--svc-host <<host-services-sparc-data()>> \
--path-cypher-resources <<path-cypher-resources-sparc-data()>> \
#+end_src
**** deploy
:properties:
:visibility: folded
:end:
#+name: run-deploy-services-sparc-data
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-deploy-services-sparc-data
<<&source-scigraph-functions>>
deploy-services \
--config <<path-build-sparc-data()>>/<<file-stem-services-output()>>.yaml \
--server aws-scigraph-data
#+end_src
**** build-deploy
:properties:
:custom_id: sparc-data-services-build-deploy
:visibility: folded
:end:
#+name: run-build-deploy-services-sparc-data
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-build-deploy-services-sparc-data
<<run-build-services-sparc-data>>
|| exit $?
<<run-deploy-services-sparc-data>>
#+end_src
*** variables                                                      :noexport:
:properties:
:visibility: folded
:end:
**** load graph
Set =path-build-sparc-data= here
#+name: path-build-sparc-data
: /tmp/scigraph-build/sparc-data

Set =folder-name-graph-sparc-data= here
#+name: folder-name-graph-sparc-data
: sparc-data

Set =path-ontologies-sparc-data= here
#+name: path-ontologies-sparc-data
: ~/git/sparc-curation/resources/scigraph/ontologies-sparc-data.yaml

**** build services config
Set =path-cypher-resources-sparc-data= here
#+name: path-cypher-resources-sparc-data
: ~/git/sparc-curation/resources/scigraph/cypher-resources.yaml

Set =host-services-sparc-data= here
#+name: host-services-sparc-data
: sparc-data.scicrunch.io
** dev local ontology
*** graph
**** deploy
:properties:
:visibility: folded
:end:
#+name: run-deploy-graph-sparc-local
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-deploy-graph-sparc-local
<<&source-scigraph-functions>>
deploy-graph \
--path-build <<path-build-sparc()>>
#+end_src
*** services config
**** build
**** deploy
:properties:
:visibility: folded
:end:
#+name: run-deploy-services-sparc-local
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-deploy-services-sparc-local
<<&source-scigraph-functions>>
deploy-services --config <<path-build-sparc()>>/<<file-stem-services-output()>>.yaml
#+end_src
**** build-deploy
** dev local sparc-data
*** graph
**** deploy
:properties:
:visibility: folded
:end:
#+name: run-deploy-graph-sparc-data-local
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-deploy-graph-sparc-data-local
<<&source-scigraph-functions>>
deploy-graph \
--path-build <<path-build-sparc-data()>> \
--folder-name-runtime <<folder-name-runtime-sparc-data-local()>>
#+end_src
*** services config
**** build
:properties:
:visibility: folded
:end:
#+name: run-build-services-sparc-data-local
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-build-services-sparc-data-local
<<&source-scigraph-functions>>
./build-services \
--path-build <<path-build-sparc-data()>> \
--path-cypher-resources <<path-cypher-resources-sparc-data()>> \
--file-stem <<file-stem-sparc-data-local()>> \
--folder-name-runtime <<folder-name-runtime-sparc-data-local()>> \
#+end_src
**** deploy
:properties:
:visibility: folded
:end:
#+name: run-deploy-services-sparc-data-local
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-deploy-services-sparc-data-local
<<&source-scigraph-functions>>
deploy-services --config <<path-build-sparc-data()>>/<<file-stem-sparc-data-local()>>.yaml
#+end_src
**** build-deploy
*** variables                                                      :noexport:
:properties:
:visibility: folded
:end:
Set =folder-name-runtime-sparc-data-local= here
#+name: folder-name-runtime-sparc-data-local
: sparc-data

Set =file-stem-sparc-data-local= here
#+name: file-stem-sparc-data-local
: services-sparc
* Components
:PROPERTIES:
:header-args: :mkdirp yes
:END:
There are three main components for SciGraph infrastructure: code, graph, and services config.
Each has a creation step (compile, load, and build respectively) and a deploy section.

Unless you need to fix some of the code here, this heading is probably not relevant.
** Code
Code is compiled once for all deployments.
*** Compile
**** RPM
:properties:
:visibility: folded
:end:
The easiest way to deploy SciGraph to RHEL-like systems is to build an RPM using
[[file:./scigraph.spec]].

If you are building on a system that does not have an RPM based package manager then
you will need the second bit to prevent builds from failing due to missing dependencies.

#+name: rpmmacros
#+caption: [[file:${HOME}/.rpmmacros][~/.rpmmacros]]
#+begin_src rpm-spec :tangle ~/.rpmmacros :tangle no
%__arch_install_post \
    [ "%{buildarch}" = "noarch" ] || QA_CHECK_RPATHS=1 ; \
    case "${QA_CHECK_RPATHS:-}" in [1yY]*) /usr/lib/rpm/check-rpaths ;; esac \
        echo no qa here
    # /usr/lib/rpm/check-buildroot
#+end_src

#+name: run-compile-scigraph-rpm
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :results output
pushd rpmbuild
# pull changes if the local repo already exists
if [ -d BUILD/SciGraph/.git ]; then
    git --git-dir BUILD/SciGraph/.git pull
fi

# build the rpm
spectool -g -R SPECS/scigraph.spec
rpmbuild --nodeps --define "_topdir `pwd`" -ba SPECS/scigraph.spec

# inspect the preinstall script
rpm -qp --scripts RPMS/noarch/scigraph-9999-0.noarch.rpm
popd
#+end_src
**** ontload only
:properties:
:visibility: folded
:end:
#+name: path-build-scigraph
: /tmp/scigraph-build/scigraph

Set up a virtualenv if required.
#+begin_src bash
pushd venvs
mkdir scigraph-build
pushd scigraph-build
pipenv --python 3.7
pipenv shell
pip install pyontutils
mkdir build
#+end_src

Compile SciGraph.
#+name: run-compile-scigraph-git
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-compile-scigraph-git
<<&source-scigraph-functions>>
compile-scigraph-git
#+end_src

By default this will install scigraph-load in
[[file:/tmp/scigraph-build/scigraph/bin/]]. You should be able to link that
file in your personal [[file:${HOME}/bin]] folder or add =/tmp/scigraph-build/scigraph/bin/=
to your path. You can move the jar file that it points to, if you do just make sure
to update the =scigraph-load= script to point to the new location.
#+name: scigraph-load-linking-options
#+begin_src bash :noweb yes
mkdir ~/bin  # copy and paste insurance
export PATH=~/bin:${PATH}  # should be set in ~/.bashrc or similar
cp <<path-build-scigraph()>>/bin/scigraph-load ~/bin/
# OR
ln -s <<path-build-scigraph()>>/bin/scigraph-load ~/bin/
# OR
export PATH=<<path-build-scigraph()>>/bin:${PATH}
#+end_src

#+name: zsh-fix
#+header: :comments noweb
#+begin_src bash :exports none :tangle ./bin/scigraph-functions.sh
if [ $ZSH_VERSION ] && [[ ! -o shwordsplit ]]; then
    echo WARNING: you have sourced this script into a zsh shell
    echo when you are done you need to run '`unsetopt shwordsplit`'
    echo otherwise your shell is likely to be broken in strange ways
    echo since we set '`setopt shwordsplit`' to avoid IFS issues
    setopt shwordsplit
    unset IFS  # otherwise ${IFS# style comments break}
fi
#+end_src

#+name: &check-path
#+header: :comments noweb
#+begin_src bash :exports none :tangle ./bin/scigraph-functions.sh
function check-file () {
    local FAIL=
    for f in $@; do
        if [ ! -f $f ]; then
            FAIL=1
            echo $f does not exist!
        fi
    done
    [ -z $FAIL ] || return 1
}

function check-dir () {
    local FAIL=
    for d in $@; do
        if [ ! -d $d ]; then
            FAIL=1
            echo $d does not exist!
        fi
    done
    [ -z $FAIL ] || return 1
}
#+end_src

#+name: &vars-compile-scigraph-git
#+begin_src bash :noweb yes :exports none
local POSITIONAL=()
while [[ $# -gt 0 ]]
do
key="$1"
case $key in
    --path-build) local PATH_BUILD="${2}"; shift; shift ;;
    --path-zip)   local PATH_ZIP="${2}"; shift; shift ;;
    --path-git)   local PATH_GIT="${2}"; shift; shift ;;
    --git-ref)    local GIT_REF="${2}"; shift; shift ;;
    *)            POSITIONAL+=("$1"); shift ;;
esac
done

local PATH_BUILD=${PATH_BUILD:-<<path-build-scigraph()>>}
local PATH_ZIP=${PATH_ZIP:-${PATH_BUILD}}
local PATH_GIT=${PATH_GIT:-${PATH_BUILD}}
local GIT_REF=${GIT_REF:-master}

#+end_src

The definition of =compile-scigraph-git= for reference.
#+name: compile-scigraph-git
#+header: :comments noweb
#+begin_src bash :noweb no-export :tangle ./bin/scigraph-functions.sh
function compile-scigraph-git () {
    <<&vars-compile-scigraph-git>>
    ontload scigraph \
    --zip-location ${PATH_ZIP}  ${IFS# build artifacts will be deposited here} \
    --git-local ${PATH_GIT}     ${IFS# remote repos will be cloned here} \
    --scigraph-branch ${GIT_REF} \
    ${POSITIONAL[*]}
}
#+end_src
**** docker
:properties:
:visibility: folded
:end:
https://github.com/SciGraph/SciGraph/tree/master/docker
*** Deploy
=SERVER= is the name in the .ssh/config
**** RPM
:properties:
:visibility: folded
:end:
#+name: rpm-install
#+begin_src bash :exports none
yum install -y scigraph*.rpm || \
yum reinstall -y scigraph*.rpm
#+end_src

#+begin_src bash
function run-deploy-scigraph-rpm () {
    echo TODO
}
#+end_src

#+begin_src bash
run-deploy-scigraph-rpm --server aws-scigraph-data
--path-rpm ~/files/rpmbuild/RPMS/noarch/scigraph-9999-0.noarch.rpm
#+end_src

#+name: run-deploy-code-rpm
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-deploy-code-rpm
# TODO backup the old rpm?
rsync --rsh ssh ~/files/rpmbuild/RPMS/noarch/scigraph-9999-0.noarch.rpm ${SERVER}:
ssh ${SERVER} '
    sudo <<rpm-install>>'
ssh ${SERVER} '
    sudo systemctl restart scigraph'
#+end_src

If you want to have more than one service or have a different name for =services.yaml=
then take a look at =/lib/systemd/system/scigraph.service= and take what you want to
customize and put it in =/etc/systemd/system/scigraph.service.d/scigraph.conf=
(retaining the section headers).
***** Updating
Beware when updating, if you have made any changes to =/lib/systemd/system/scigraph.service=
in order to tweak the JVM those changes will be klobbered when running =yum reinstall -y scigraph*.rpm=.
Until I can figure out how to get systemd to accept the JVM config options as something that can,
you know, be configured instead of something that has to be static, this is going to be a problem.
**** git
**** docker
:properties:
:visibility: folded
:end:
https://github.com/SciGraph/SciGraph/tree/master/docker
** Graph
*** Load
**** scigraph-load
:PROPERTIES:
:VISIBILITY: folded
:END:

#+name: &vars-load-graph
#+begin_src bash :eval never :exports none :noweb yes
local POSITIONAL=()
while [[ $# -gt 0 ]]
do
key="$1"
case $key in
    --path-build)        local PATH_BUILD="${2}"; shift; shift ;;
    --folder-name-graph) local FOLDER_NAME_GRAPH="${2}"; shift; shift ;;
    --path-graphload)    local PATH_GRAPHLOAD="${2}"; shift; shift ;;
    --path-ontologies)   local PATH_ONTOLOGIES="${2}"; shift; shift ;;
    *)                   POSITIONAL+=("$1"); shift ;;
esac
done

local PATH_GRAPHLOAD=${PATH_GRAPHLOAD:-<<path-graphload-template()>>}
local PATH_ONTOLOGIES=${PATH_ONTOLOGIES:-"./ontologies.yaml"}  # if missing will error
local PATH_BUILD=$(readlink -m ${PATH_BUILD:-<<path-build-graph()>>})
local FOLDER_NAME_GRAPH=${FOLDER_NAME_GRAPH:-<<folder-name-graph()>>}
local LOAD_GRAPH_PATH="${PATH_BUILD}/${FOLDER_NAME_GRAPH}"
local PATH_CONFIG_YAML="${LOAD_GRAPH_PATH}/graphload-$(date +%Y-%m-%d).yaml"
local PATH_CONFIG_YAML_RAW="${PATH_CONFIG_YAML}.raw"
local STAMPED="${FOLDER_NAME_GRAPH}-graph-$(date +%Y%m%dT%H%M%S)"
local FILE_NAME_ZIP="${STAMPED}.zip"
local PATH_ZIP="${PATH_BUILD}/${FILE_NAME_ZIP}"
local LATEST="${PATH_BUILD}/LATEST"
echo $LOAD_GRAPH_PATH $FOLDER_NAME_GRAPH $STAMPED $FILE_NAME_ZIP $PATH_ZIP
check-file $PATH_GRAPHLOAD $PATH_ONTOLOGIES || return $?
#+end_src

#+name: load-graph
#+header: :comments noweb
#+begin_src bash :noweb no-export :tangle ./bin/scigraph-functions.sh
function load-graph () {
    <<&vars-load-graph>>

    if [[ -z "${PATH_ONTOLOGIES}" ]]; then
        echo no ontologies section specified
        exit 1
    fi

    if [[ -d "${LOAD_GRAPH_PATH}" ]]; then
        rm "${LOAD_GRAPH_PATH}" -r
    fi
    mkdir -p "${LOAD_GRAPH_PATH}" || return $?
    cat "${PATH_GRAPHLOAD}" "${PATH_ONTOLOGIES}" > "${PATH_CONFIG_YAML_RAW}" || return $?
    yq -Y ".graphConfiguration.location = \"${LOAD_GRAPH_PATH}\"" \
        "${PATH_CONFIG_YAML_RAW}" > "${PATH_CONFIG_YAML}" || return $?
        # FIXME I think this line is bugged YES BUT ALSO BY THE VERY COMMENT ITSELF
    scigraph-load -c "${PATH_CONFIG_YAML}" || return $?

    pushd "${PATH_BUILD}" || return $?
    # mv prevents accidentally deploying the same graph twice
    # but use cp -r for development to avoid continual rebuild
    cp -r ${FOLDER_NAME_GRAPH} ${STAMPED} || return $?
    zip -r ${FILE_NAME_ZIP} ${STAMPED} || return $?
    unlink "${LATEST}" > /dev/null 2>&1
    ln -sT "${FILE_NAME_ZIP}" "${LATEST}" || return $?
    popd > /dev/null || return $?
}
#+end_src
**** ontload
:PROPERTIES:
:VISIBILITY: folded
:END:
# sigh command line flags inside of flags

#+name: &vars-load-graph-ontload
#+begin_src bash :eval never :exports none :noweb yes
local POSITIONAL=()
while [[ $# -gt 0 ]]
do
key="$1"
case $key in
    --path-graphload)  local PATH_GRAPHLOAD="${2}"; shift; shift ;;
    --path-ontologies) local PATH_ONTOLOGIES="${2}"; shift; shift ;;
    --path-build)      local PATH_BUILD="${2}"; shift; shift ;;
    --path-zip)        local PATH_ZIP="${2}"; shift; shift ;;
    --path-git)        local PATH_GIT="${2}"; shift; shift ;;
    --git-ref)         local GIT_REF="${2}"; shift; shift ;;
    *)                 POSITIONAL+=("$1"); shift ;;
esac
done

local PATH_GRAPHLOAD=${PATH_GRAPHLOAD:-<<path-graphload-template()>>}
local PATH_ONTOLOGIES=${PATH_ONTOLOGIES:-"./ontologies.yaml"}
local PATH_BUILD=${PATH_BUILD:-<<path-build-graph()>>}
local PATH_ZIP=${PATH_ZIP:-"${PATH_BUILD}"}
local PATH_GIT=${PATH_GIT:-"${PATH_BUILD}"}
local GIT_REF=${GIT_REF:-"master"}
check-file $PATH_GRAPHLOAD $PATH_ONTOLOGIES || return $?
#+end_src

#+name: load-graph-ontload
#+header: :comments noweb
#+begin_src bash :noweb no-export :tangle ./bin/scigraph-functions.sh
function load-graph-ontload () {
    <<&vars-load-graph-ontload>>
    ontload graph \
    --org SciCrunch  ${IFS# github organization} \
    NIF-Ontology     ${IFS# repo name} \
    NIF              ${IFS# pattern for remote base (e.g. http://) to swap for local file://,
                       NIF automatically expands to http://ontology.neuinfo.org/NIF} \
    --zip-location ${PATH_ZIP}      ${IFS# output folder where the loaded graph zip will be exported} \
    --git-local ${PATH_GIT}         ${IFS# location where git repo will be cloned} \
    --branch ${GIT_REF}             ${IFS# git ref (branch, commit, etc.) from which to build} \
    --graphload-config ${PATH_GRAPHLOAD}       ${IFS# path to graphload-base-template.yaml} \
    --graphload-ontologies ${PATH_ONTOLOGIES}  ${IFS# path to ontologies-graph-name.yaml} \
    ${POSITIONAL[*]}  ${IFS# pass any other unhandled arguments along}
}
#+end_src

If loading fails, then you probably need to patch something in which case you will
need the following commands. See an example setup in [[../nifstd/patches/][nifstd/patches]].
If =--patch= is enabled and the patch config cannot be found you will get an error.

# TODO
#+name: run-load-graph-ontload-patch
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-load-graph-ontload-patch
<<&source-scigraph-functions>>
load-graph-ontload \
--patch                      ${IFS# do apply patches} \
--patch-config patches.yaml  ${IFS# path to patche files} \
$@
#+end_src
**** ontload only
:PROPERTIES:
:VISIBILITY: folded
:END:
When loading using pyontutils without a dedicated SciGraph install include the following
to use the version of SciGraph built from git in [[compile-scigraph-git][compile-scigraph-git]].

Any of the =run-load-graph-*= commands defined below can be run with one additional argument
to use =scigraph-load= built from git. If you have moved =scigraph-load= to =~/bin= you do not
need to do this unless you are doing this to test a specific version of SciGraph or similar.

#+name: run-load-graph-ontload-scigraph-git
#+header: :shebang "#!/usr/bin/env bash" :tangle-mode (identity #o755)
#+begin_src bash :noweb yes :tangle ./bin/run-load-graph-ontload-scigraph-git
run-load-graph-sparc --path-build-scigraph <<path-build-scigraph()>>
#+end_src
*** Deploy
:PROPERTIES:
:VISIBILITY: folded
:END:

#+name: &vars-deploy-graph-local
#+begin_src bash :noweb yes :exports none
local POSITIONAL=()
while [[ $# -gt 0 ]]
do
key="$1"
case $key in
    --path-zip)            local PATH_ZIP="${2}"; shift; shift ;;
    --path-runtime)        local PATH_RUNTIME="${2}"; shift; shift ;;
    --folder-name-runtime) local FOLDER_NAME_RUNTIME="${2}"; shift; shift ;;
    *)                     POSITIONAL+=("$1"); shift ;;
esac
done
if [ ! -f "${PATH_ZIP}" ]; then
    echo $PATH_ZIP path does not exist.
    echo Not deploying.
    return 1
fi
local FILE_NAME_ZIP=$(basename "${PATH_ZIP}")
local STAMPED="${FILE_NAME_ZIP//.zip/}"

local PATH_RUNTIME=${PATH_RUNTIME:-<<path-runtime()>>}
local FOLDER_NAME_RUNTIME=${FOLDER_NAME_RUNTIME:-<<folder-name-runtime()>>}
#+end_src

#+name: &local-deploy-command
#+caption: &local-deploy-command
#+header: :comments noweb
#+begin_src bash :noweb yes
cp ${PATH_ZIP} ${PATH_RUNTIME} || return $?
pushd ${PATH_RUNTIME} || return $?
unzip -n ${FILE_NAME_ZIP} || return $?
chown -R ${SVC_USER}:${SVC_USER} ${STAMPED} || return $?
service-manager scigraph stop
unlink ${FOLDER_NAME_RUNTIME} > /dev/null 2>&1
ln -sT ${STAMPED} ${FOLDER_NAME_RUNTIME} || echo relink failed
service-manager scigraph start
popd
#+end_src

#+name: &vars-deploy-graph
#+begin_src bash :noweb yes :exports none
local POSITIONAL=()
while [[ $# -gt 0 ]]
do
key="$1"
case $key in
    --path-build)          local PATH_BUILD="${2}"; shift; shift ;;
    --server)              local SERVER="${2}"; shift; shift ;;
    --svc-user)            local SVC_USER="${2}"; shift; shift ;;
    --path-runtime)        local PATH_RUNTIME="${2}"; shift; shift ;;
    --folder-name-runtime) local FOLDER_NAME_RUNTIME="${2}"; shift; shift ;;
    --path-zip)            local PATH_ZIP="${2}"; shift; shift ;;
    *)                     POSITIONAL+=("$1"); shift ;;
esac
done

local PATH_BUILD=${PATH_BUILD:-<<path-build-graph()>>}

local SERVER=${SERVER:-localhost}
local SVC_USER=${SVC_USER:-scigraph}
local PATH_RUNTIME=${PATH_RUNTIME:-<<path-runtime()>>}
local FOLDER_NAME_RUNTIME=${FOLDER_NAME_RUNTIME:-<<folder-name-runtime()>>}

local LATEST="${PATH_BUILD}/LATEST"
if [ ! -f "${LATEST}" ]; then
    echo $LATEST path does not exist.
    echo Did you actually build the graph?
    echo Not deploying.
    return 1
fi
local FILE_NAME_ZIP=$(readlink "${LATEST}")
local STAMPED="${FILE_NAME_ZIP//.zip/}"
local PATH_ZIP=${PATH_ZIP:-"${PATH_BUILD}/${FILE_NAME_ZIP}"}
if [ ! -f "${PATH_ZIP}" ]; then
    echo $PATH_ZIP path does not exist.
    echo Not deploying.
    return 1
fi
local SERVER_AS_SCIGRAPH="${SERVER}-scigraph"  # by convention
#echo $FOLDER_NAME_GRAPH $STAMPED $FILE_NAME_ZIP $PATH_ZIP
#+end_src

#+name: deploy-graph
#+header: :comments noweb
#+begin_src bash :noweb no-export :tangle ./bin/scigraph-functions.sh
function deploy-graph () {
    <<&vars-deploy-graph>>
    echo Will deploy graph to ${SERVER}:${PATH_RUNTIME}
    echo $PATH_ZIP
    <<&are-you-sure>>

    if [ "${SERVER}" = "localhost" ]; then
        su - root -c "$(typeset -f service-manager);
                      <<&local-deploy-command>>" || return $?
    else
        rsync --rsh ssh "${PATH_ZIP}" "${SERVER_AS_SCIGRAPH}:${PATH_RUNTIME}" || return $?
        ssh ${SERVER_AS_SCIGRAPH} "pushd \"${PATH_RUNTIME}\"; unzip -n \"${FILE_NAME_ZIP}\"" || return $?

        ssh -t ${SERVER} "$(typeset -f service-manager); service-manager scigraph stop" || return $?

        ssh ${SERVER_AS_SCIGRAPH} "
            unlink \"${PATH_RUNTIME}/${FOLDER_NAME_RUNTIME}\"
            ln -sT \"${PATH_RUNTIME}/${STAMPED}\" \"${PATH_RUNTIME}/${FOLDER_NAME_RUNTIME}\"" || echo relink failed

        ssh -t ${SERVER} "$(typeset -f service-manager); service-manager scigraph start"
    fi
}
#+end_src
*** variables                                                      :noexport:
:PROPERTIES:
:VISIBILITY: folded
:END:
Set =path-build-graph= here
#+NAME: path-build-graph
: /tmp/scigraph-build

Set =path-graphload-template= here
#+name: path-graphload-template
: ~/git/pyontutils/nifstd/scigraph/graphload-base-template.yaml

Set =folder-name-graph= here
#+name: folder-name-graph
: graph

Set =path-runtime= here
#+name: path-runtime
: /var/lib/scigraph

Set =folder-name-runtime= here
#+name: folder-name-runtime
: graph
** Services Config
*** Build
:PROPERTIES:
:VISIBILITY: folded
:END:
#+name: &vars-build-services
#+begin_src bash :noweb yes :exports none
local POSITIONAL=()
while [[ $# -gt 0 ]]
do
key="$1"
case $key in
    --path-build)            local PATH_BUILD="${2}"; shift; shift ;;
    --path-runtime)          local PATH_RUNTIME="${2}"; shift; shift ;;
    --folder-name-runtime)   local FOLDER_NAME_RUNTIME="${2}"; shift; shift ;;
    --path-cypher-resources) local PATH_CYPHER_RESOURCES="${2}"; shift; shift ;;
    --path-services)         local PATH_SERVICES="${2}"; shift; shift ;;
    --path-curies)           local PATH_CURIES="${2}"; shift; shift ;;
    --file-stem)             local FILE_STEM="${2}"; shift; shift ;;
    --svc-host)              local SVC_HOST="${2}"; shift; shift ;;
    --svc-port)              local SVC_PORT="${2}"; shift; shift ;;
    *) POSITIONAL+=("$1"); shift ;;
esac
done

local PATH_BUILD=${PATH_BUILD:-<<path-build-services()>>}
local PATH_RUNTIME=${PATH_RUNTIME:-<<path-runtime()>>}
local FOLDER_NAME_RUNTIME=${FOLDER_NAME_RUNTIME:-<<folder-name-runtime()>>}
local PATH_CYPHER_RESOURCES=${PATH_CYPHER_RESOURCES:-"./cypher-resources.yaml"}  # will fail on absense
local PATH_SERVICES=${PATH_SERVICES:-<<path-services()>>}
local PATH_CURIES=${PATH_CURIES:-<<path-curies()>>}
local FILE_STEM=${FILE_STEM:-<<file-stem-services-output()>>}
local SVC_HOST=${SVC_HOST:-localhost}
local SVC_PORT=${SVC_PORT:-9000}
local URL_BASE="http://${SVC_HOST}:${SVC_PORT}"
local URL_VIEW="${URL_BASE}/scigraph/refine/view/{{id}}"
local URL_PREVIEW="${URL_BASE}/scigraph/refine/preview/{{id}}"
local PATH_RUNTIME_FOLDER_GRAPH="${PATH_RUNTIME}/${FOLDER_NAME_RUNTIME}"
local YAML="${FILE_STEM}.yaml"
local DT=$(date +%Y%m%dT%H%M%S)
local YAML_RAW="${FILE_STEM}-${DT}.yaml.raw"

local PATH_YAML="${PATH_BUILD}/${YAML}"
local PATH_YAML_RAW="${PATH_BUILD}/${YAML_RAW}"
check-file $PATH_CYPHER_RESOURCES $PATH_SERVICES $PATH_CURIES || return $?
#+end_src

#+name: build-services
#+header: :comments noweb
#+begin_src bash :noweb no-export :tangle ./bin/scigraph-functions.sh
function build-services () {
    <<&vars-build-services>>
    # make build location
    mkdir -p "${PATH_BUILD}"

    # TODO allow urls?
    # make raw
    cat "${PATH_SERVICES}" > "${PATH_YAML_RAW}" || return $?
    yq -Sy '' "${PATH_CURIES}" | sed 's/^/    /' >> "${PATH_YAML_RAW}" || return $?
    cat "${PATH_CYPHER_RESOURCES}" >> "${PATH_YAML_RAW}" || return $?

    # make services header
    echo "# ${YAML_RAW}" > "${PATH_YAML}"

    # make services
    yq -Y ".graphConfiguration.location = \"${PATH_RUNTIME_FOLDER_GRAPH}\" |
    .serviceMetadata.view.url = \"${URL_VIEW}\" |
    .serviceMetadata.preview.url = \"${URL_PREVIEW}\"
    " "${PATH_YAML_RAW}" >> "${PATH_YAML}" || return $?
}
#+end_src
*** Deploy
:PROPERTIES:
:VISIBILITY: folded
:END:
# TODO
Once =services.yaml= has been created rsync the raw and expanded configs
to the target host.

#+name: &vars-deploy-services
#+begin_src bash :noweb yes :exports none
local POSITIONAL=()
while [[ $# -gt 0 ]]
do
key="$1"
case $key in
    --config)       local CONFIG="${2}"; shift; shift ;;
    --server)       local SERVER="${2}"; shift; shift ;;
    --path-runtime) local PATH_RUNTIME="${2}"; shift; shift ;;
    *)              POSITIONAL+=("$1"); shift ;;
esac
done

if [ -z $CONFIG ]; then
    echo '--config' is required
    return 1
fi

local CONFIG=${CONFIG:-}
local SERVER=${SERVER:-localhost}
local PATH_RUNTIME=${PATH_RUNTIME:-<<path-runtime()>>}

local YAML=$(basename "${CONFIG}")
if [ ! -f "${CONFIG}" ]; then
    echo ${CONFIG} path does not exist.
    echo Did you actually build the config?
    echo Not deploying.
    return 1
fi
local YAML_RAW=$(head -n 1 "${CONFIG}" | cut -b3-)
local CONFIG_RAW="$(dirname ${CONFIG})/${YAML_RAW}"
local EXISTING="${PATH_RUNTIME}/${YAML}"

local SERVER_AS_SCIGRAPH="${SERVER}-scigraph"  # by convention
local SERVER=${SERVER}
if [ ${SERVER} = localhost ]; then
    local TARGET="${PATH_RUNTIME}"
else
    local TARGET="${SERVER_AS_SCIGRAPH}:${PATH_RUNTIME}"
fi
#+end_src

#+name: deploy-services
#+header: :comments noweb
#+begin_src bash :noweb no-export :tangle ./bin/scigraph-functions.sh
function deploy-services () {
    # NOTE it is on YOU to make sure you are deploying the right config
    # to the right server, under normal circumstances you should
    # be running a run-build-deploy-services-* command
    <<&vars-deploy-services>>
    echo Will deploy services config to $TARGET
    echo $CONFIG_RAW
    echo $CONFIG
    <<&are-you-sure>>
    local CMD='
        <<&deploy-services-backup-config>>'
    echo $CONFIG_RAW $TARGET
    if [ ${SERVER} = localhost ]; then
        backup-services-config "${EXISTING}" "${PATH_RUNTIME}" "${YAML}" || return $?
        cp "${CONFIG_RAW}" "${TARGET}" || return $?
        cp "${CONFIG}" "${TARGET}" || return $?
        ${CMD_RESTART} || return $?
    else
        # if only we could rsync
        ssh ${SERVER_AS_SCIGRAPH} "$(typeset -f backup-services-config); backup-services-config ${EXISTING} ${PATH_RUNTIME} ${YAML}" || return $?
        rsync --rsh ssh "${CONFIG_RAW}" "${TARGET}" || return $?
        rsync --rsh ssh "${CONFIG}" "${TARGET}" || return $?
        ssh -t ${SERVER} "$(typeset -f service-manager); service-manager scigraph restart" || return $?
    fi
}
#+end_src

#+name: backup-services-config
#+header: :comments noweb
#+begin_src bash :noweb no-export :tangle ./bin/scigraph-functions.sh
function backup-services-config () {
    local EXISTING=${1}
    local PATH_RUNTIME=${2}
    local YAML=${3}
    local E_YAML_RAW=$(head -n 1 "${EXISTING}" | grep "^#" | cut -b3-)
    if [ -n "${E_YAML_RAW}" ]; then
        local YAML_BACKUP="${PATH_RUNTIME}/${E_YAML_RAW//.raw/}"
    else
        local mod_dt=$(stat -c %y "${EXISTING}" | cut -d "." -f1 | sed "s/[-\:]//g" | sed "s/\ /T/")
        local YAML_BACKUP="${PATH_RUNTIME}/${YAML}-${mod_dt}"
    fi
    cp -a "${EXISTING}" "${YAML_BACKUP}"
}
#+end_src

*** variables                                                      :noexport:
:PROPERTIES:
:VISIBILITY: folded
:END:
Set =path-services= here
#+name: path-services
: ~/git/pyontutils/nifstd/scigraph/services-base-template.yaml

Set =path-curies= here
#+name: path-curies
: ~/git/pyontutils/nifstd/scigraph/curie_map.yaml
# FIXME rename to curies.yaml and be done with it

Set =path-build-services= here
#+name: path-build-services
: ./

Set =file-stem-services-output= here
#+name: file-stem-services-output
: services
** Other processes
*** ssh setup
:PROPERTIES:
:CUSTOM_ID: ssh-setup
:VISIBILITY: folded
:END:

#+name: &vars-ssh-keygen-deploy
#+begin_src bash :exports none
local POSITIONAL=()
while [[ $# -gt 0 ]]
do
key="$1"
case $key in
    --server)   SERVER="${2}"; shift; shift ;;
    --svc-user) SVC_USER="${2}"; shift; shift ;;
    --keyname)  local KEYNAME="${2}"; shift; shift ;;
    *)          POSITIONAL+=("$1"); shift ;;
esac
done

if [ -z $SERVER ]; then
    echo '--server' is required
    return 1
elif [ -z $SVC_USER ]; then
    echo '--svc-user' is required
    return 1
fi

local KEYNAME_DEFAULT=${HOSTNAME}.${USER}.${SERVER}.${SVC_USER}
local KEYNAME=${KEYNAME:-${KEYNAME_DEFAULT}}
local KEYTYPE=ed25519  # this is hardcoded for now
KEYPATH=~/.ssh/id_${KEYTYPE}.${KEYNAME}
SUDO_OR_SU='$(command -v sudo && echo sudo ${0} -c || echo For su on ${HOSTNAME} 1>& 2; echo su -c)'
#+end_src

#+name: ssh-functions
#+header: :comments noweb
#+begin_src bash :noweb no-export :tangle ./bin/scigraph-functions.sh
function ssh-keygen-simple () {
    <<&vars-ssh-keygen-deploy>>

    # test if the key already exists
    if [ -f "${KEYPATH}" ]; then
        echo "${KEYPATH}" already exists not running keygen and not deploying
        unset KEYPATH SERVER SVC_USER SUDO_OR_SU
        return 1
    fi

    # test that root access is available
    # FIXME requires double password entry in the su case
    ssh -t ${SERVER} "${SUDO_OR_SU} \"echo we have root access\"" && export HAVE_ROOT=1 || return $?

    # generate the key
    ssh-keygen -t ${KEYTYPE} -N "" -C "${USER}@${HOSTNAME}" -f "${KEYPATH}"

    # all the relevant environment variables are left in the environment
    # for the next step
}

function ssh-copy-id-simple () {
    # note that &vars-ssh-keygen-deploy is written in such a way that
    # the environment variables will persist if they are specified on
    # ssh-keygen-simple and thus do not have to be set again in here
    # they are included so that ssh-keygen-deploy can be used by itself
    <<&vars-ssh-keygen-deploy>>
    <<&command-ssh-copy-id-remote>>
    # test that root access is available if HAVE_ROOT is not set
    if [ -z $HAVE_ROOT ]; then
        ssh -t ${SERVER} "${SUDO_OR_SU} \"echo we have root access\"" && \
        export HAVE_ROOT=1 || return $?
    fi

    # copy the key to the host
    TEMP_RANDOM_NAME=$(head /dev/urandom | tr -dc A-F0-9 | head -c 20)
    rsync --rsh ssh ${KEYPATH}.pub ${SERVER}:${TEMP_RANDOM_NAME}.pub || return $?
    # TODO option to deploy private key if the key is generated for a service user

    # and today we learn about typeset, sigh
    ssh -t ${SERVER} "${SUDO_OR_SU} '$(typeset -f copy-id-to-user-authorized-keys); copy-id-to-user-authorized-keys ${TEMP_RANDOM_NAME}.pub ${SVC_USER}'"

    local oops=$?
    if [ $oops -ne 0 ]; then
        echo FAILED so ${SERVER}:${TEMP_RANDOM_NAME}.pub is still present
        return $oops
    fi
    unset KEYPATH SERVER SVC_USER SUDO_OR_SU TEMP_RANDOM_NAME
}
#+end_src

#+name: &command-ssh-copy-id-remote
#+begin_src bash :eval never
function copy-id-to-user-authorized-keys () {
    PUB_KEY=${1}
    SVC_USER=${2}
    UHOME=$(eval echo ~${SVC_USER})
    if [ ! -d ${UHOME}/.ssh ]; then
        mkdir ${UHOME}/.ssh
    fi
    if [ ! -f ${UHOME}/.ssh/authorized_keys ]; then
        touch ${UHOME}/.ssh/authorized_keys
        chown ${SVC_USER}:${SVC_USER} ${UHOME}/.ssh
    fi
    cat ${PUB_KEY} >> \
    ${UHOME}/.ssh/authorized_keys && \
    chown ${SVC_USER}:${SVC_USER} ${UHOME}/.ssh && \
    rm ${PUB_KEY};
}
#+end_src
*** Confirm action
:PROPERTIES:
:VISIBILITY: folded
:END:

#+name: &are-you-sure
#+begin_src bash
printf "Are you sure you want to deploy? y/N "
if [ $ZSH_VERSION ]; then
    read -r -k 1 choice
else
    read -r -n 1 choice
fi
case "${choice}" in
    y|Y) echo ;;
    n|N) echo; echo "Not deploying."; return 1;;
    '?') echo; echo "$(set -o posix; set | grep -v '^_')"; return 1;;
    *)   echo; echo "Not deploying."; return 1;;
esac
echo "Deploying ..."
#+end_src
*** Restart services
:PROPERTIES:
:VISIBILITY: folded
:END:
**** service-manager
A bash function that implements a portable =service-manager= command.
#+name: &service-manager
#+header: :comments noweb
#+begin_src bash :noweb no-export :tangle ./bin/scigraph-functions.sh
function service-manager () {
    SVCNAME=${1}
    ACTION=${2}
    if [ $(command -v systemctl) ]; then
        local CMD="systemctl ${ACTION} ${SVCNAME}"
        if [ "${ACTION}" = "start" ]; then
            local CMD_POST="systemctl status ${SVCNAME}"
        else
            # if we are stopping then status will return a non-zero value
            # which will confuses the signal we want which would be if
            # the program failed to stop, not is stopped
            local CMD_POST=""
        fi
    elif [ $(command -v rc-service) ]; then
        local CMD="rc-service ${SVCNAME} ${ACTION}"
        local CMD_POST=""
    else
        echo unknown service-manager
        return 1
    fi

    echo ${CMD}

    if [[ $EUID = 0 ]]; then
        ${CMD} || return $?
    elif [ $(command -v sudo) ]; then
        sudo ${CMD} || return $?
    else
        echo For su on ${HOSTNAME}
        su -c "${CMD}" || return $?
    fi

    if [ -n "${CMD_POST}" ]; then
       sleep 5
       $CMD_POST
    fi
}
#+end_src
**** Amazon Linux 2 :noexport:
:PROPERTIES:
:VISIBILITY: folded
:END:
#+NAME: restart-services-aws
#+header: :async t
#+begin_src bash :dir /ssh:hostname|sudo:hostname:
systemctl restart scigraph
#+end_src

# #+CALL: restart-services-aws() :dir (:dir-tramp-sudo "aws-scigraph") :eval never
# #+CALL: test-scigraph-host() :var SERVER="scigraph.scicrunch.io" :eval never
*** Testing
:PROPERTIES:
:VISIBILITY: folded
:END:
#+name: test-scigraph-host
#+header: :results none
#+begin_src bash :var SERVER="localhost" :var PORT=9000
ontutils scigraph-stress --scigraph-api http://${SERVER}:${PORT}/scigraph
#+end_src
** variables :noexport:
Set =path-scigraph-functions= here
#+name: path-scigraph-functions
: ~/git/pyontutils/nifstd/scigraph/bin/scigraph-functions.sh

#+name: &source-scigraph-functions
#+begin_src bash :noweb yes :exports none
source "$(eval echo <<path-scigraph-functions()>>)"
#+end_src
* Per operating system :noexport:
:properties:
:visibility: folded
:end:
# Reminder that, sigh, it is impossible to use #+include: in the current doc build pipeline
# because org mode cannot include from the current buffer
** Gentoo
*** Setup
**** Build host
# #+include: (concat (buffer-file-name) "::#Setup:Build host:Gentoo") :only-contents t
**** Services host
# #+include: (concat (buffer-file-name) "::#Setup:Services host:Gentoo") :only-contents t
*** Code
**** Build
**** Deploy
*** Graph
**** Build
**** Deploy
*** Config
**** Build
**** Deploy
** Ubuntu
*** Setup
**** Build host
# #+include: (concat (buffer-file-name) "::#Setup:Build host:Ubuntu") :only-contents t
# **** Services host
# #+include: (concat (buffer-file-name) "::#Setup:Services host:Ubuntu") :only-contents t
** AWS Linux 2
*** Setup
**** Services host
# #+include: (concat (buffer-file-name) "::#Setup:Services host:AWS Linux 2") :only-contents t
